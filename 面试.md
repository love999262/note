## 前言
当前市面上的前端面经层出不穷，但是正是因为多，才导致很多人在想要找面经的时候无从下手，不知道到底要看什么，贪多嚼不烂，面对收藏夹里茫茫多的面经不知道复习重点在哪，哪些知识点是高频的，哪些又已经过时了，很多文章的内容又是重复的，从而在准备的过程中浪费了许多不必要的时间。

本文根据作者个人面试经验以及偏好精选了一些高频面试题，而并不会事无巨细的将每一个前端知识点都收入囊中。最终目的是让读者用较短的时间看完本篇后，能覆盖绝大多数面试场景，从而提升准备效率。

## 正文

### HTML
#### [盒模型](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Building_blocks/The_box_model)
盒模型（Box Model）是CSS（层叠样式表）中用于定义网页元素布局和尺寸的核心概念。在HTML文档中，每个元素都被视为一个矩形的盒子，这个盒子由以下几个部分组成：

1.  **内容区域（Content）** ：这是元素的主体部分，它包含了元素的实际内容，如文本、图像、视频等。设置`width`和`height`属性时，按照标准盒模型，这两个值仅影响内容区域的大小。
1.  **内边距（Padding）** ：围绕内容区域四周的是内边距，它为内容区域提供了空白空间。可以通过`padding-top`、`padding-right`、`padding-bottom`和`padding-left`属性来设置各边的内边距大小。内边距是透明的，不影响背景颜色的渲染。
1.  **边框（Border）** ：紧接着内边距的是边框，边框可以有宽度、样式（实线、虚线等）和颜色属性，分别通过`border-width`、`border-style`和`border-color`设置。
1.  **外边距（Margin）** ：最外面是外边距，它定义了元素与其他元素之间的距离，确保了元素间的间距。外边距是透明的，也不影响背景颜色。可以通过`margin-top`、`margin-right`、`margin-bottom`和`margin-left`属性设置各个方向的外边距。

关于盒模型有两种主要计算方式：

-   **标准盒模型（W3C Box Model）** ：当声明元素的`width`和`height`时，这些值仅仅应用于内容区域。内边距和边框不会增加元素的整体宽度和高度。
-   **IE盒模型（Quirks Mode 或怪异盒模型）** ：在一些老版本的IE浏览器中，默认的盒模型行为是将`width`和`height`属性包括了内容、内边距和边框。为了统一不同浏览器的行为，CSS3引入了`box-sizing`属性，通过设置`box-sizing: border-box;`可以使元素遵循IE盒模型的计算方式，即包括内边距和边框在内的尺寸才是元素的总宽高。而在默认的标准盒模型下，`box-sizing: content-box;`表示宽度和高度不包括内边距和边框。

#### 浏览器多标签页之间的通信方式

https://juejin.cn/post/7002012595200720927

浏览器多标签页之间的通信主要有以下几种方式：

1.  **LocalStorage/SessionStorage**

    -   `localStorage`和`sessionStorage`是HTML5提供的Web Storage API，它们提供了持久化存储机制，数据在同一域名下的不同标签页间可以共享。当一个标签页对`localStorage`或`sessionStorage`进行读写操作时，将会触发`storage`事件，其他同源标签页可以通过监听这个事件来接收通知并作出相应反应。

1.  **Cookies**

    -   Cookies虽然主要用于身份验证和跟踪用户状态，但也可以作为浏览器各个标签页间共享信息的一种方式。不过，由于其大小限制、安全性以及每次HTTP请求都会携带的特性，通常不推荐用于大量数据或者实时通信。

1.  **WebSockets**

    -   使用WebSocket协议可以建立浏览器与服务器间的双向通信通道。各个标签页可以通过各自连接到同一个WebSocket服务器，并通过服务器中转消息来间接实现彼此之间的通信。

1.  **Shared Workers**

    -   Shared Worker是一种浏览器内置的工作线程，它可以被多个浏览器标签页共享，这样就可以通过共享的Worker进程作为中介，在不同的标签页间传递消息。

1.  **Broadcast Channel API**

    -   HTML5引入的Broadcast Channel API允许来自同一源的不同上下文（比如不同标签页、窗口、iframe）之间创建一个简单的通信信道，通过它可以直接发送和接收消息。

1.  **PostMessage API**

    -   虽然PostMessage API主要用于跨窗口（包括跨域窗口）的消息传递，但在某些场景下也可用于同一站点内的多标签页通信，例如通过消息中心或其他类型的内部消息队列机制。

总结来说，对于多标签页通信，最常用的手段可能是`localStorage`配合`storage`事件，以及利用现代浏览器提供的更直接的通信接口如Broadcast Channel API。如果是需要实时性较高或复杂的数据交换，则可能倾向于选择WebSocket这种网络层的解决方案。
#### HTML5本地存储方案
HTML5为网页应用提供了多种本地存储方案，主要包括以下几种：

1.  **[localStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/localStorage)**
    -   localStorage是一个持久化存储，用于在用户浏览器端存储大量数据（约5MB左右）。数据存储在本地，直到被明确删除或达到存储限制为止，即使浏览器关闭后重新打开，数据仍然存在。数据是以键值对（key-value pairs）的形式存储的，适合长期保存用户设置、应用数据等。

1.  **[sessionStorage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/sessionStorage)**

    -   sessionStorage与localStorage相似，也是以键值对形式存储数据，但它只在当前浏览器会话中有效。一旦浏览器窗口或标签页关闭，sessionStorage中的数据就会被清除。这对于保存临时会话状态或临时用户输入非常有用。

1.  **[IndexedDB](https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API)**

    -   IndexedDB是一个更高级的客户端数据库，允许存储大量结构化数据，支持索引和查询。相比于localStorage，IndexedDB提供了更复杂的数据模型和更大的存储容量，适合存储大量结构化数据，如离线应用的数据缓存。

1.  **Web SQL Database**

    -   Web SQL Database曾是一个W3C草案，现已不再推荐使用，但在一些老旧浏览器中仍能得到支持。它是一个嵌入到浏览器中的SQLite数据库，允许执行SQL查询来操作存储的数据。

1.  **Cache API (Service Worker)**

    -   与上述存储方案不同，Cache API主要用于离线缓存，是PWA（Progressive Web Apps）的关键技术之一。通过Service Worker，开发者可以预先缓存静态资源，使得在离线环境下也能提供部分功能和服务。

1.  **File System API（已废弃）**

    -   File System API最初是为了允许网页应用程序直接访问用户的本地文件系统，但由于隐私和安全方面的担忧，大部分浏览器已经停止支持此API。

综上所述，HTML5本地存储方案主要是localStorage、sessionStorage和IndexedDB，以及其他辅助存储技术，如Service Worker配合Cache API，它们共同增强了Web应用程序的离线能力和本地数据处理能力。
#### [WebWorker](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API)

Web Worker是HTML5引入的一项技术，它允许JavaScript在浏览器后台独立于主线程（UI线程）运行脚本，从而能够执行一些计算密集型、长时间运行的任务，而不会阻塞主线程，保证用户界面的流畅交互。

具体而言，Web Worker通过创建一个新的执行上下文（工作线程）来运行JavaScript代码，这个上下文与主线程相互独立，拥有自己的事件循环。Web Worker可以执行各种CPU密集型操作，例如大数据计算、文件读取或解析、复杂的算法执行等。它与主线程之间的通信是通过消息传递机制完成的，即通过`postMessage()`方法发送消息，然后在Worker线程和主线程之间通过`onmessage`事件监听和处理消息。

需要注意的是，Web Worker由于运行在独立线程中，无法直接访问DOM或修改网页内容，但可以访问部分全局对象，如`navigator`、`location`的部分只读属性，并且拥有自己独立的全局作用域，可以使用`importScripts()`方法导入外部脚本。

Web Worker有两种类型：

-   **常规Worker（Dedicated Worker）** ：为每个Worker创建一个独立的线程，一次只能处理一项任务。
-   **共享Worker（Shared Worker）** ：可以被多个浏览器上下文（例如多个标签页或窗口）共享，允许在多个上下文间共享数据和状态。

通过Web Worker技术，开发者可以有效地分离Web应用的计算密集型任务，改善用户体验，特别是在处理复杂逻辑时避免造成页面卡顿或无响应。

#### [postMessage](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)

https://juejin.cn/post/6844903665694687240
`postMessage`是HTML5引入的一种跨文档消息传递（Cross-document messaging）API，它允许来自不同源（window、iframe或worker）的脚本在保证安全的前提下进行通信。通过`postMessage`方法，一个窗口可以向另一个窗口发送一条消息，接收到消息的窗口通过监听`message`事件来获取并处理这条消息。

**基本用法：**

1.  发送消息：

    ```
    Javascript
    1// 在发送消息的窗口（或iframe、worker）中
    2otherWindow.postMessage(message, targetOrigin);
    ```

    其中：

    -   `message`：要发送的数据，可以是任何类型，但会转换为字符串格式进行传递。
    -   `targetOrigin`：指定消息可以发送到的源（协议、主机名、端口号），如果是"*"，则不限制目标源，但这样做可能存在安全风险。

1.  接收消息：

    ```
    Javascript
    1window.addEventListener('message', function(event) {
    2  if (event.origin === expectedOrigin) { // 校验发送消息的源是否可信
    3    var receivedMessage = event.data;
    4    // 在这里处理接收到的消息
    5  }
    6}, false);
    ```

    其中：

    -   `event.data`：接收到的消息内容。
    -   `event.origin`：发送消息窗口的源。

**应用场景**：

-   跨窗口（iframe间、弹窗与主页面间）通信。
-   跨域资源共享（CORS）的补充，实现不同域名下的页面间数据交换。
-   Web Worker与主页面之间的数据交换。

`postMessage`方法极大地增强了网页间的交互能力，使得复杂多窗口或多源的应用场景得以实现，同时也加强了网页的安全性，只有在指定目标源的情况下，消息才能被正确接收和处理。

#### [WebSocket](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket)


WebSocket是一种在单个TCP连接上进行全双工通信的协议，它允许客户端和服务器之间进行实时、双向的数据传输。WebSocket的设计目的是为了让Web应用程序能够实时推送数据，而不是传统的HTTP协议那样只有客户端发起请求，服务器才能响应。

WebSocket的工作原理如下：

1.  初始化握手阶段：客户端通过升级HTTP协议，发送一个特殊的WebSocket请求到服务器，请求头中包含了升级协议的信息。服务器如果支持WebSocket，会同意这次协议升级，返回101 Switching Protocols状态码，并在Upgrade头部字段表明协议已升级为WebSocket。
1.  建立连接后：连接成功建立之后，WebSocket的连接就保持着打开的状态，双方都可以随时向对方发送数据。数据帧以二进制格式传输，支持文本和二进制数据类型。
1.  数据传输阶段：与HTTP不同，WebSocket连接一旦建立就不需要为每一次数据传输重新建立连接或发起请求，因此可以提供低延迟、实时的通讯服务。
1.  断开连接：当一方想要断开连接时，可以通过发送特定的关闭帧来结束WebSocket连接。

WebSocket广泛应用于实时聊天、股票报价、游戏、协同编辑等需要实时双向通信的场景。在浏览器中，WebSocket API可以通过`WebSocket`构造函数实例化一个WebSocket对象，然后通过其方法进行连接、发送和接收数据。
#### [File API](https://developer.mozilla.org/zh-CN/docs/Web/API/File)

File API是HTML5引入的一组API，它允许Web应用程序访问用户计算机上的文件系统，从而实现上传文件、读取文件内容、展示文件信息等功能。File API主要包括以下几个核心组成部分：

1.  **FileList对象**： 当用户通过 `<input type="file">` 控件选择文件后，可通过 `files` 属性获取一个FileList对象，该对象包含了用户所选的所有文件。
1.  **File对象**： 每个从FileList对象中获取的项都是一个File对象，它包含了文件的相关信息，如名称、大小、类型、修改日期等，并且可以通过FileReader接口读取文件内容。
1.  **FileReader接口**： FileReader接口提供了异步读取Blob或File对象的方法，可以用来读取用户设备上的文件内容。它支持的方法包括 `readAsText`、`readAsDataURL`、`readAsArrayBuffer` 等，分别用于读取文本、Base64编码的数据URL和原始二进制数组。
1.  **Blob对象**： Blob对象代表不可变的、原始数据的类文件对象。它可以是用户上传的文件，也可以是JavaScript生成的数据。Blob可以被FileReader读取，也可以通过URL.createObjectURL()方法生成一个临时的URL用于引用这个Blob对象，以便在网页中显示或下载。
1.  **FileWriter接口**（部分浏览器支持）： FileWriter接口提供了对用户文件系统进行读写操作的能力，允许Web应用向用户设备上指定的文件写入数据。但要注意的是，出于安全考虑，不是所有浏览器都支持FileWriter，而且这个接口的使用受到严格的权限限制。

File API极大地增强了Web应用程序对本地文件系统的访问能力，使得在线办公、文件处理、拖拽上传等多种涉及文件操作的功能得以实现。

#### [video](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/video)与[audio](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/audio) API
HTML5中的`<video>`和`<audio>`元素及其相应的JavaScript API为网页媒体播放带来了原生支持，消除了对Flash等插件的依赖。这些API允许开发者直接在浏览器中控制音频和视频内容，包括加载、播放、暂停、音量调整、播放进度控制以及其他高级功能。

以下是`<video>`和`<audio>`元素以及它们对应的API的一些主要特性：

**Video API**

-   `<video>`标签：用于在网页中嵌入视频内容。

    -   属性：

        -   `src`: 指定视频文件源。
        -   `autoplay`: 是否自动播放。
        -   `preload`: 可以设置为`none`、`metadata`或`auto`，决定视频资源的预加载策略。
        -   `controls`: 显示默认的播放控制条。
        -   更多属性，例如loop、muted、poster等。

    -   JavaScript API：

        -   `currentTime`: 获取或设置当前播放位置。
        -   `play()`: 开始或恢复播放。
        -   `pause()`: 暂停播放。
        -   `volume`: 音量控制。
        -   `duration`: 获取视频总时长。
        -   `ended`事件：当视频播放结束时触发。
        -   还有许多其他事件和方法，如`canPlayType()`检测浏览器是否支持特定格式，`addEventListener()`用于监听播放状态变化等。

**Audio API**

-   `<audio>`标签：类似`<video>`标签，用于嵌入音频内容。

    -   同样具有上述大部分`<video>`标签的属性和方法。

-   JavaScript API同样适用于`<audio>`元素，包括控制播放、暂停、音量、播放位置等操作。

开发者可以根据需要通过这些API构建自定义的播放器界面和交互逻辑，同时兼容不同浏览器对于音频和视频格式的支持情况，可能需要提供多种格式的源文件以确保跨浏览器兼容性。

#### [canvas](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/canvas)
HTML5 `<canvas>` 元素是用于在网页上绘制图形的一种强大工具，它提供了一个可编程的绘图表面，允许开发人员使用JavaScript来动态生成图形和图像。`<canvas>` 元素本身不包含任何内容，但它定义了一个区域，开发者可以通过JavaScript API来绘制图形、制作动画、实现交互式效果等。

以下是 `<canvas>` 使用的基本步骤：

1.  **声明 canvas 元素**： 在HTML文档中添加一个`<canvas>`元素，设置宽度和高度属性。

    ```
    Html
    <canvas id="myCanvas" width="500" height="500"></canvas>
    ```

1.  **获取 canvas 上下文**： 通过JavaScript获取canvas元素，并创建绘图环境。主要有两种类型的上下文：“2d”（二维绘图）和“webgl”（三维WebGL绘图）。

    ```
    Javascript
    var canvas = document.getElementById('myCanvas');
    var ctx = canvas.getContext('2d'); // 获取2D绘图上下文
    // 或者
    var gl = canvas.getContext('webgl'); // 获取WebGL绘图上下文
    ```

1.  **绘图操作**： 使用获取的上下文对象进行各种绘图操作，例如填充颜色、画线、画圆、绘制图像、添加文本等。

    ```
    Javascript
    ctx.fillStyle = 'rgb(200, 0, 0)';
    ctx.fillRect(10, 10, 150, 100); // 填充一个红色矩形
    
    ctx.beginPath();
    ctx.arc(95, 50, 40, 0, Math.PI * 2, true);
    ctx.fillStyle = 'green';
    ctx.fill(); // 画一个绿色圆形
    ```

1.  **高级功能**： `canvas` API还支持更复杂的图形绘制，如贝塞尔曲线、渐变填充、阴影效果、图像合成等。对于WebGL，可以用来创建基于着色器的3D图形和场景。

通过HTML5 `<canvas>` 元素及其JavaScript API，开发者能够创造出丰富的视觉体验，从简单的图表到复杂的交互式游戏和数据可视化应用都可以实现。

##### canvas离屏渲染
Canvas离屏渲染是一种提高渲染效率的技术，主要是为了减少页面重绘的开销和提高性能。离屏渲染的核心思想是将复杂的绘图操作或者频繁更新的部分在一个不可见的Canvas（也称为离屏Canvas，即OffscreenCanvas）上完成，然后再一次性或按需将这个预渲染的结果复制到实际可见的Canvas上。

**离屏Canvas (OffscreenCanvas)** ：

-   OffscreenCanvas API允许在Web Worker线程中独立于主线程进行Canvas的渲染工作，从而释放主线程处理其他任务，尤其是对于CPU密集型的绘图操作或实时渲染场景，这能显著改善用户体验，防止因为长时间的渲染阻塞而导致的界面卡顿。
-   OffscreenCanvas对象可以直接在Worker线程中创建并使用，也可以从主线程上的普通Canvas元素通过`transferControlToOffscreen()`方法获得。

**应用场景**：

-   动态背景或复杂元素的预先绘制和复用。
-   实时渲染，比如视频流的帧处理，或者是游戏中的复杂场景渲染。
-   图形资源的预加载和缓存。
-   高性能动画和特效的实现，特别是当它们不需要直接与用户交互时。

**使用离屏渲染的一般步骤**：

1.  创建一个OffscreenCanvas实例。
1.  在OffscreenCanvas上进行所有的绘图操作。
1.  完成绘制后，可以通过`getImageData()`或`toDataURL()`获取像素数据，或者将OffscreenCanvas作为源通过`drawImage()`方法绘制到主Canvas上。

在WebGL中，离屏渲染还可以结合WebGLRenderTarget来实现，通过设置渲染目标为一个非默认帧缓冲区，从而达到类似的效果。

总之，离屏渲染有助于提升canvas图形性能的关键在于将耗时的渲染过程异步化和分隔化，从而减小对页面刷新率的影响，并且优化整体渲染流程。
### CSS
#### [BFC](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_display/Block_formatting_context)

https://juejin.cn/post/6844903495108132877

区块格式化上下文（Block Formatting Context, BFC）是CSS布局模型中的一个概念，它定义了一个独立的渲染区域，内部的布局不受外部浮动元素的影响，并且遵循一套特定的渲染规则。BFC内的元素布局不会与BFC外部的元素相互重叠，而且可以包含浮动元素，清除浮动对周围元素的影响。

BFC的主要特性包括：

1.  **内部布局规则**：

    -   BFC中的块级元素会在垂直方向上一个接一个放置。
    -   水平方向上，元素会尽量靠左或靠右放置，具体取决于书写模式。
    -   每个元素的左边缘（对于从左到右的书写模式）会紧贴包含块的左边，除非遇到浮动元素或其他边界。

1.  **边距折叠阻止**：

    -   在同一个BFC中的相邻块级元素的垂直外边距会发生折叠（即取两者中较大的一个作为最终外边距）。
    -   不同BFC之间的元素则不会发生垂直外边距折叠。

1.  **浮动元素包容**：

    -   BFC能够包容其内部所有的浮动元素，即使这些浮动元素导致了高度塌陷，BFC的边框也能扩展以包含它们，从而解决了浮动元素对后续元素布局的影响问题。

1.  **布局限制**：

    -   BFC内部的元素不会与外部浮动元素重叠。

创建BFC的常见方式包括但不限于：

-   设置 `float` 属性值不为 `none` 的元素。
-   设置 `position` 属性值为 `absolute` 或 `fixed` 的元素。
-   设置 `display` 属性值为 `inline-block`、`table-cell`、`table-caption` 或 `flex`、`grid` 等。
-   设置 `overflow` 属性值不为 `visible` 的块级元素。

通过创建BFC，开发人员可以更好地控制布局，解决由于浮动引起的许多布局问题，并实现更为精确的页面布局设计。

#### [伪类](https://developer.mozilla.org/zh-CN/docs/Web/CSS/Pseudo-classes)
CSS伪类（Pseudo-classes）是CSS选择器中的一种特殊类别，它们用于选择元素基于特定状态而非其内容或属性值。伪类可以帮助开发者根据用户交互、DOM树关系、导航历史等动态条件为元素添加样式。

以下是几个常见的CSS伪类：

1.  **用户交互伪类**：

    -   `:hover`：当鼠标悬浮在元素上时匹配。
    -   `:active`：当元素被激活（例如，被点击时）匹配。
    -   `:focus`：当元素获得焦点时匹配（例如，通过键盘Tab键访问或点击元素）。

1.  **结构性伪类**：

    -   `:first-child`：选择元素在其父元素的第一个子元素时匹配。
    -   `:last-child`：选择元素在其父元素的最后一个子元素时匹配。
    -   `:nth-child(n)`：选择其父元素的第n个子元素时匹配，可以是数字、关键词（even、odd）或者公式。
    -   `:not(selector)`：选择不匹配指定选择器的元素。
    -   `:only-child`：如果元素是其父元素中唯一的子元素，则匹配。
    -   `:empty`：如果元素没有子元素（包括文本节点）时匹配。

1.  **链接伪类**：

    -   `:link`：匹配尚未访问过的链接（a元素）。
    -   `:visited`：匹配用户已访问过的链接。
    -   `:target`：当锚点（id）与当前URL片段标识符匹配时匹配。

1.  **表单控件状态伪类**：

    -   `:enabled`：匹配可用的表单控件（如input、select等）。
    -   `:disabled`：匹配禁用的表单控件。
    -   `:checked`：匹配被选中的表单控件，如复选框（checkbox）或单选按钮（radio button）。

1.  **CSS Grid 和 Flexbox 伪类**：

    -   `:nth-of-type-an` 和 `:nth-last-of-type(n)`：在CSS Grid或Flexbox布局中，根据元素在某一类型中的位置选择元素。
    -   `:nth-last-child(n)` 和 `:nth-child(-n+3)`：在布局中选择特定位置的元素。

使用伪类的例子：

```
Css
/* 鼠标悬停时改变链接颜色 */
a:hover {
  color: red;
}

/* 第一个段落背景色为浅灰色 */
p:first-child {
  background-color: lightgray;
}
0
/* 已访问过的链接变为紫色 */
a:visited {
  color: purple;
}

/* 表单中被选中的复选框文字颜色为绿色 */
input[type=checkbox]:checked + label {
  color: green;
}
```

这些伪类有助于构建更加动态和交互性强的Web界面，使得CSS能够根据元素的状态而非静态属性来定义样式。
#### [媒体查询](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_media_queries)
CSS媒体查询（Media Queries）是CSS3的一个强大特性，它允许开发者根据设备的不同特性（如视口尺寸、屏幕分辨率、设备方向、色彩能力等）来应用不同的CSS样式规则。媒体查询的主要用途在于创建响应式网站设计，使得网页能根据访问它的设备环境动态地调整布局、字体大小和其他视觉表现。

在实际编写CSS时，媒体查询通常采用`@media`规则的形式：

```
Css
@media media-type and (media-feature) {
  /* 当媒体类型和媒体特性满足条件时，这里的CSS样式将会生效 */
  selector {
    property: value;
  }
}
```

-   `media-type` 指定媒体类型，最常见的是 `screen`（用于电脑屏幕、手机和平板）、`print`（用于打印预览）等，现在几乎总是默认使用 `screen`。

-   `media-feature` 是一组媒体特性及其值的表达式，比如：

    -   `width`：设备视口宽度。
    -   `height`：设备视口高度。
    -   `orientation`：设备的方向，可以是 `portrait` 或 `landscape`。
    -   `resolution`：设备的分辨率。

    例如：

```
Css
/* 当视口宽度小于或等于600px时 */
@media screen and (max-width: 600px) {
  body {
    background-color: lightblue;
  }
}

/* 当视口宽度大于600px但小于900px时 */
@media screen and (min-width: 600px) and (max-width: 900px) {
  .my-class {
    font-size: 18px;
  }
}
```

通过这样的方式，设计师和开发者可以确保网页在不同尺寸和类型的设备上都能提供良好的用户体验，实现了内容的适应性和可访问性。随着移动设备和高清显示屏的普及，媒体查询已经成为现代前端开发不可或缺的一部分。

#### [flex布局](https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex)

FLEX布局，全称为Flexible Box布局模型，是一种CSS布局模式，专为改进网页布局的一致性和灵活性而设计。在Flex布局中，容器（父元素）能够改变其子元素的宽、高以及顺序，以最优方式填充可用空间，或者根据需要调整大小以适应容器空间的变化。

以下是Flex布局的核心概念和特点：

1.  **Flex容器（Flex Container）** ：任何元素只要设置了 `display: flex;` 或 `display: inline-flex;` 就会变成一个Flex容器。容器内的子元素将会作为Flex项目（Flex Items）参与布局。
1.  **主轴（Main Axis）与交叉轴（Cross Axis）** ：Flex布局中有两个关键轴向。主轴是Flex项目沿着容器的主要方向排列的轴线，而交叉轴则是与主轴垂直的轴线。
1.  **Flex方向（flex-direction）** ：通过 `flex-direction` 属性可以设定主轴的方向，如 `row`（默认，水平从左到右）、`row-reverse`、`column`（垂直从上到下）、`column-reverse`。
1.  **Flex流（Flex Wrap）** ：通过 `flex-wrap` 属性控制Flex项目是否能在一条轴线上换行，如 `nowrap`（默认，不换行）、`wrap`（允许换行）和 `wrap-reverse`（反向换行）。
1.  **对齐方式（Justify Content / Align Items / Align Self）** ：这些属性分别用于控制Flex项目在主轴上的对齐方式、在交叉轴上的对齐方式以及单个Flex项目本身的对齐方式。
1.  **Flex生长因子（Flex Grow）与收缩因子（Flex Shrink）** ：Flex项目可以根据 `flex-grow` 和 `flex-shrink` 属性值按比例放大或缩小自身尺寸，以填充容器剩余空间或适应容器空间减小时的情况。
1.  **Flex基值（Flex Basis）** ：通过 `flex-basis` 属性可以指定Flex项目在分配空间之前的基础尺寸。

总之，Flex布局以其强大的灵活性和响应性著称，能够轻易实现对齐、方向调整、空间分配等各种复杂的布局需求，特别适合移动端和响应式网页设计。随着现代浏览器对Flexbox规范的广泛支持，它已经成为Web开发中布局设计的重要工具之一。


#### [CSS动画](https://developer.mozilla.org/zh-CN/docs/Web/CSS/animation)
CSS动画是CSS3引入的一种强大特性，允许开发者通过纯CSS代码创建丰富的动态效果。CSS动画能够使HTML元素从一种样式逐渐、平滑地过渡到另一种样式，从而实现动画效果，无需依赖JavaScript或其他插件。

CSS动画主要包括两个关键部分：

1.  **@keyframes 规则**：

    -   `@keyframes`关键字用于定义动画的序列，其中包含了动画过程中不同阶段的样式。

    -   在`@keyframes`内部，通过百分比（如0%, 25%, 50%, 75%, 100%）来指定动画的进度点，并在每个进度点处设置元素的不同样式。

    -   可以使用关键词`from`代表0%，`to`代表100%，例如：

        ```
        Css
         @keyframes move {
           from { width: 100px; }
           to { width: 200px; }
         }
        ```

1.  **动画应用**：

    -   使用`animation`属性将动画应用到具体的HTML元素上。

    -   `animation`属性是一个复合属性，它可以接受多个子属性来定义动画的各个方面，包括：

        -   `animation-name`：指定要使用的@keyframes动画名称。
        -   `animation-duration`：定义动画完成一个周期所花费的时间。
        -   `animation-timing-function`：定义动画的速度曲线（如ease、linear、ease-in-out等）。
        -   `animation-delay`：动画开始前的延迟时间。
        -   `animation-iteration-count`：动画重复的次数（如无限循环可以用`infinite`）。
        -   `animation-direction`：决定动画是否反向播放（如正向、反向、交替）。
        -   其他还有`animation-fill-mode`（动画结束后如何填充样式）等属性。

例如，将上面定义的`move`动画应用到一个元素上：

```
Css
 div {
   animation: move 1s ease-in-out infinite;
 }
```

这样，指定的`div`元素就会按照`move`动画定义的内容，以1秒钟的持续时间、ease-in-out的缓动效果无限次地执行宽度从100px到200px的变化动画。

#### [transitions](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transition)
CSS Transitions API 是CSS3中的一项重要特性，它允许开发者定义当一个CSS属性从一个值改变到另一个值时的过渡效果，从而实现了平滑、连续的动画效果。这种过渡不需要借助JavaScript，仅通过CSS就能完成，既节省资源又提高了效率。

以下是一些关键概念和用法：

##### 关键属性

1.  **transition-property**

    -   定义哪些CSS属性会发生过渡效果。可以指定单个属性，多个属性，或者使用`all`关键字表示所有可以过渡的属性。

    ```
    Css
     .example {
       transition-property: background-color, transform;
     }
    ```

1.  **transition-duration**

    -   设置过渡效果持续的时间，单位通常是秒(s)或毫秒(ms)。

    ```
    Css
      .example {
       transition-duration: 0.5s;
     }
    ```

1.  **transition-timing-function**

    -   定义过渡过程的速度曲线，例如线性、加速然后减速、先慢后快等。常用的有ease、linear、ease-in、ease-out、ease-in-out、cubic-bezier()函数等。

    ```
    Css
     .example {
       transition-timing-function: ease-in-out;
     }
    ```

1.  **transition-delay**

    -   设置过渡开始前的延迟时间。

    ```
    Css
     .example {
       transition-delay: 0.2s;
     }
    ```

##### 简写形式

上述四个属性可以合并为一个简写属性`transition`：

```
Css
 .example {
   transition: property duration timing-function delay;
 }
 
 /* 示例 */
 .example {
   transition: background-color 0.5s ease-in-out 0.2s, transform 0.8s linear;
 }
```

##### 使用场景

-   当鼠标悬停（`:hover`）、获取焦点（`:focus`）或其他触发状态改变时，元素的某个或多个样式会平滑过渡到新的状态。

```
Css
 .button {
   background-color: lightblue;
   transition: background-color 0.3s;
 }
 
 .button:hover {
   background-color: darkblue;
 }
```

在这个例子中，当`.button`元素被鼠标悬停时，其背景色将在0.3秒内平滑过渡到深蓝色。

总之，CSS Transitions API简化了网页动画的制作流程，并提供了流畅、自然的视觉效果，大大提高了用户体验。

#### [transform](https://developer.mozilla.org/zh-CN/docs/Web/CSS/transform)
CSS Transform 属性是用来在二维或三维空间中操纵元素的外观，包括旋转、缩放、移动（平移）、倾斜等操作。这个属性允许开发者对元素的位置和形状进行动态变化，且这些变化不会影响文档流中的其他元素布局。Transform 的强大之处在于它能够实现复杂的动画效果和交互式设计，尤其是在现代Web开发中配合CSS Transition 和 Animation 来创建平滑的变换动画。

以下是一些关键的Transform方法：

1.  **rotate()** ：

    -   用于旋转元素。接受度数作为参数，正数代表逆时针旋转，负数代表顺时针旋转。

    ```
    Css
     .rotate-element {
       transform: rotate(45deg);
     }
    ```

1.  **translate()** ：

    -   用于平移元素。接受水平(x轴)和垂直(y轴)方向的距离作为参数，单位可以是像素(px)、百分比(%)等。

    ```
    Css
     .translate-element {
       transform: translate(50px, 100px);
     }
    ```

1.  **scale()** ：

    -   用于缩放元素。接受两个参数分别对应X轴和Y轴的缩放比例，如果只提供一个参数，则X轴和Y轴按相同比例缩放。

    ```
    Css
     .scale-element {
       transform: scale(1.5); /* 同比例放大1.5倍 */
     }
    ```

1.  **skew()** ：

    -   用于使元素倾斜。接受两个参数分别表示X轴和Y轴的倾斜角度。

    ```
    Css
     .skew-element {
       transform: skew(20deg, 10deg);
     }
    ```

1.  **matrix()** ：

    -   用于更复杂的二维或三维变换，它接收六个参数，可以同时完成旋转、缩放和平移操作。

    ```
    Css
    .matrix-element {
       transform: matrix(1, 2, 3, 4, 5, 6);
     }
    ```

此外，还有三维变换如：

-   `rotateX()`, `rotateY()`, `rotateZ()` 或 `rotate3d()` 对元素进行三维旋转
-   `translate3d()`, `translateZ()` 进行三维平移
-   `scale3d()`, `scaleZ()` 进行三维缩放

综合示例：

```
Css
 element {
   transform: translateX(50px) translateY(100px) rotate(45deg) scale(1.5);
 }
```

以上代码会使`.element`首先向右平移50px，向下平移100px，接着旋转45度，最后整体缩放至1.5倍大小。同时，结合CSS Transition或Animation属性，可以轻松实现这些变换的动画效果。

#### CSS硬件加速
在CSS中，为了提升动画性能和利用设备的GPU来提高渲染速度，可以通过开启硬件加速来优化页面上的动画效果。这通常涉及到使用一些特定的CSS属性，特别是当涉及到transform和opacity属性的动画时，浏览器会自动触发硬件加速。

以下是如何开启硬件加速的几种方式：

1.  使用 `transform: translateZ(0)` 或 `translate3d(0, 0, 0)`：

    -   将一个3D变换应用到元素上有时可以强制浏览器使用GPU来渲染该元素及其动画。

    ```
    Css
    .accelerated-element {
      transform: translate3d(0, 0, 0);
    }
    ```

    即使没有实质性的3D变换，仅添加这一属性也可以触发硬件加速。

1.  使用 `will-change` 属性：

    -   提前告知浏览器某个属性即将发生变化，并可能需要硬件加速。

    ```
    Css
    .animating-element {
      will-change: transform; /* 或 opacity 等需要加速的属性 */
    }
    ```

    注意：过度使用 `will-change` 可能会导致内存占用增加，因此应在真正需要时才声明，并在动画结束时撤销声明。

1.  在现代浏览器中，对 `transform` 和 `opacity` 属性的应用通常会自动触发硬件加速，所以只要直接使用这些属性做动画，就很可能已经启用了硬件加速。

例如，当你为元素定义了一个包含动画的keyframes规则：

```
Css
 @keyframes slideIn {
   from {
    transform: translateX(-100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
0}

.accelerated-animation {
  animation: slideIn 1s ease-in-out forwards;
}
```

在这个例子中，由于使用了 `transform` 和 `opacity` 动画，浏览器很可能会自动启用硬件加速来提升动画性能。但是，对于更复杂的情况或者老旧的浏览器，可能需要手动通过上述技术开启硬件加速。
##### CSS硬件加速原理
硬件加速，尤其是在Web开发中的CSS领域，是指浏览器利用图形处理单元（GPU）来帮助渲染复杂的图形和动画，而不是单纯依赖CPU的软件渲染。这是因为GPU设计用于并行处理大量与图形相关的计算任务，特别适合用来渲染3D变换、复合层以及动画效果，其效率远高于CPU。

当CSS中开启了硬件加速，浏览器会将部分渲染工作转移到GPU上，创建一个新的“合成层”（composited layer），并将该层存储在GPU内存中独立渲染。这意味着每次更新时，GPU可以直接操作这个层的内容而不需要重新构建整个页面的像素数据，大大提高了渲染效率。

以下是几个开启硬件加速的CSS属性及背后原理：

1.  **Transforms**：3D变换如`translate3d`、`rotate3d`、`scale3d`等，即使只是简单的`translateZ(0)`也能触发创建一个新的合成层，因为GPU专长于处理三维空间内的变换。
1.  **Opacity**：更改元素的不透明度（`opacity`）也会促使浏览器创建合成层，因为GPU可以高效地混合不同透明度的图层。
1.  **`will-change`**：此属性可以提示浏览器即将发生的改变可能需要硬件加速，浏览器可以根据这个提示提前分配资源和创建合适的合成层。
1.  **动画和过渡**：CSS动画和过渡如果涉及到了上述属性，也有可能自动触发硬件加速。

总的来说，通过上述CSS属性的运用，浏览器能够识别出哪些元素的渲染过程可以受益于GPU，并相应地调整其渲染策略，从而实现硬件加速。这样做的目的是减少主线程的工作负担，加快渲染速度，提升用户体验，尤其是对于那些包含复杂动画或交互的网页而言。然而，值得注意的是，虽然硬件加速有助于提升性能，但它也有潜在的成本，比如消耗更多内存，且不适合所有场景，因此应当谨慎使用并针对具体情况进行性能测试与优化。

### 基础常识

#### [输入URL到页面显示的过程](https://www.kancloud.cn/maryong/maryong/1770626)

https://juejin.cn/post/6928677404332425223

输入URL到页面显示的过程大致可以分为以下几个步骤：

1.  **用户输入 URL**： 用户在浏览器地址栏输入或粘贴一个URL（统一资源定位符）。
1.  **DNS 解析**： 浏览器首先查找本地DNS缓存，如果找不到，则向ISP的DNS服务器发送DNS查询请求，获取该URL对应网站的IP地址。
1.  **TCP 连接**： 得到IP地址后，浏览器开始与服务器建立TCP连接（通常使用HTTP协议，HTTPS则先进行TLS/SSL握手加密连接）。
1.  **发送HTTP请求**： 浏览器构建HTTP请求报文，包含请求方法（如GET、POST等）、请求头（如User-Agent、Accept等）和可能的请求体，然后将这个请求报文通过已建立的TCP连接发送给服务器。
1.  **服务器处理请求**： 服务器接收到请求后，解析请求报文，根据请求路径找到对应的资源，进行相应的处理（如调用CGI脚本、运行服务器端代码、读取静态文件等）。
1.  **生成响应**： 服务器生成HTTP响应报文，包括状态码（如200 OK）、响应头（如Content-Type、Set-Cookie等）和响应体（即要返回给浏览器的内容，通常是HTML、CSS、JavaScript等文件）。
1.  **浏览器接收响应**： 浏览器接收到来自服务器的响应报文，开始解析响应头和响应体。
1.  **解析HTML**： 浏览器开始解析响应体中的HTML文档，构建DOM树（Document Object Model）。
1.  **下载资源**： 浏览器根据HTML文档中的链接下载其他相关资源，如CSS样式表、JavaScript文件、图片、字体等。
1.  **渲染页面**： 当HTML文档下载完毕并构建DOM树后，浏览器根据CSSOM（CSS Object Model）计算样式布局，绘制页面（Layout与Paint过程）。
1.  **执行JavaScript**： 如果页面包含JavaScript代码，浏览器会执行这些代码，可能会修改DOM结构或CSS样式，导致重新布局和绘制。
1.  **页面显示**： 经过上述步骤，浏览器完成了所有资源的下载、解析和渲染，最终将整个页面内容呈现给用户。

以上就是从输入URL到页面显示的大致过程，实际过程中还包括很多如缓存处理、重定向、并发请求优化等细节。

#### 扫码登陆的原理

https://juejin.cn/post/6924218259302694919

扫码登录是一种便捷的身份验证和授权方式，它主要用于不同平台间（例如网页端与移动端）的无缝切换登录，无需用户手动输入账号密码。下面是扫码登录的基本流程和原理概述：

1.  **生成二维码**：

    -   用户在网页端点击“扫码登录”按钮后，网页服务器生成一个全局唯一的标识符（如UUID）。
    -   这个标识符通常会被编码成一个二维码，网页端将此二维码展示给用户。

1.  **二维码关联用户身份**：

    -   生成二维码的同时，服务器会将此UUID作为一个临时密钥存储在服务器端（如Redis缓存中），并设定一个较短的有效期。
    -   存储的内容一般包括UUID以及可能的其他安全信息，如一个一次性使用的token。

1.  **移动端扫码**：

    -   用户使用手机App扫描网页上的二维码，App读取到二维码中的UUID信息。
    -   App内部已经保存了用户的登录态信息，比如用户的Token或者其他身份认证凭据。

1.  **验证请求**：

    -   手机App获取到UUID后，将该标识符与用户的认证信息（如token）打包成一个安全的请求，发送至移动端服务器。
    -   移动端服务器收到请求后，验证用户身份合法性，并与网页端服务器通信（通常是通过API调用）。

1.  **授权确认**：

    -   如果验证通过，移动端服务器通知网页端服务器这个UUID所代表的用户已经完成身份验证。
    -   在某些情况下，App还会要求用户在手机上确认是否授权登录网页端应用，以增加安全性。

1.  **网页端响应**：

    -   网页端服务器接收到授权成功的信号后，清除之前存储的UUID，同时根据移动端提供的信息识别用户，并建立相应的登录态。
    -   网页端接着跳转至登录成功的界面，用户无感知地完成了登录过程。

总结来说，扫码登录通过二维码作为中间媒介传递用户身份验证信息，利用已登录的移动端应用作为信任来源，实现了跨平台的快速登录体验，同时也保证了较高的安全性和便利性。

#### 单点登录(SSO)

https://juejin.cn/post/7044328327762411534?searchId=20240419230736B86DD478A31F92B61AB8

单点登录（Single Sign-On，简称SSO）是一种网络安全机制，允许用户在一个系统中登录后，无需再在其他相关的系统中分别进行登录就能访问这些系统中的资源。以下是单点登录的一般原理概述：

1.  **用户访问系统**：

    -   用户首先尝试访问单点登录环境中的某个应用系统（称为CAS Client或其他类型的应用客户端）。

1.  **重定向到认证中心**：

    -   应用系统检测到用户未登录，会重定向用户到统一的认证中心（CAS Server或其他SSO服务）。

1.  **用户认证**：

    -   用户在认证中心提交用户名和密码等凭证进行认证。
    -   认证中心验证用户凭证，如果有效，则认为用户已通过身份验证。

1.  **发放凭证**：

    -   认证成功后，认证中心会生成一个唯一的认证凭证，如票据（Ticket）或者令牌（Token）。
    -   认证中心通过某种方式（如设置Cookie或HTTP重定向携带Ticket/Token）将凭证传递回用户浏览器。

1.  **客户端验证**：

    -   用户浏览器在获得凭证后，再次访问原始应用系统时会携带这个凭证。
    -   应用系统（CAS Client）验证从认证中心接收到的凭证的有效性。

1.  **建立会话**：

    -   当应用系统验证凭证有效后，会在本地为用户建立会话，赋予其访问权限，此时用户已经登录到了该应用系统，无需再次输入用户名和密码。

1.  **跨系统访问**：

    -   当用户尝试访问同一单点登录环境中的其他应用系统时，同样的验证流程会简化执行，因为用户已经处于有效的认证状态。
    -   浏览器会自动携带凭证去访问新的系统，新系统也能够验证这个凭证并通过认证中心确认用户身份，从而让用户无缝地登录新系统。

不同的单点登录方案可能会采用不同的技术和协议来实现上述流程，如SAML（Security Assertion Markup Language）、JWT（JSON Web Tokens）、OAuth、OpenID Connect等。其中CAS（Central Authentication Service）是专门针对Web应用的一种较为成熟的单点登录框架，其工作流程正如上述原理所述。

#### OAuth2.0

https://juejin.cn/post/7276330110835458103?searchId=20240419231057CDB2A7126233D3B58C6E

OAuth 2.0 是一个授权框架，允许第三方应用在用户授权下访问用户的某些资源，而无需获取用户的账号密码。OAuth 2.0 主要用于授权（Authorization），它允许用户给予第三方应用有限的、特定的权限，而不用担心泄露自己的敏感信息。

**OAuth 2.0 工作流程简述：**

1.  **授权请求**：

    -   第三方应用（Client）引导用户到资源所有者的授权服务器（Authorization Server）。
    -   用户在授权服务器上登录并确认愿意给予第三方应用某些权限（Scope）。

1.  **授权码（Authorization Code Grant）** ：

    -   用户授权后，授权服务器会给第三方应用返回一个授权码（code）。
    -   第三方应用使用这个授权码和预先注册的客户端密钥（Client ID和Client Secret），向授权服务器请求访问令牌（Access Token）。

1.  **获取访问令牌**：

    -   第三方应用向授权服务器提交授权码和必要的凭证，换取访问令牌。
    -   授权服务器验证信息无误后，返回访问令牌和（可选的）刷新令牌（Refresh Token）。

1.  **访问资源**：

    -   第三方应用持有访问令牌后，每当需要访问用户资源时，在请求头中附带访问令牌，向资源服务器（Resource Server）请求数据。
    -   资源服务器验证访问令牌的有效性，若通过，则允许访问相应的资源。

1.  **令牌续期**（适用于拥有刷新令牌的情况）：

    -   访问令牌有过期时间，当过期时，第三方应用可以用刷新令牌去获取新的访问令牌，从而延长对用户资源的访问权限。

OAuth 2.0 通过这种方式保证了用户数据的安全性，同时让第三方应用能够在用户的授权下合法访问资源，而无需知道用户的登录凭证。此外，OAuth 2.0 还支持其他的授权类型，如隐式授权（Implicit）、客户端凭据授权（Client Credentials）和资源拥有者密码凭据授权（Resource Owner Password Credentials）等。

#### 服务端渲染

https://juejin.cn/post/6844903881390964744
https://juejin.cn/post/6844903569632526344

服务端渲染（Server-Side Rendering, SSR）是一种Web应用程序的渲染方式，尤其在使用诸如React、Vue、Angular等现代前端框架构建的SPA（Single Page Application）中常见。服务端渲染的基本原理是：

1.  **用户发起请求**：

    -   当用户通过浏览器访问一个支持服务端渲染的Web应用时，浏览器向服务器发送HTTP请求。

1.  **服务端响应**：

    -   服务器接收到请求后，不像传统的静态HTML页面那样直接返回已渲染好的HTML，而是运行Node.js服务或其他后端服务中的JavaScript代码，执行前端框架（如React）的渲染逻辑。

1.  **执行渲染**：

    -   服务器会执行相应的React组件树（或Vue、Angular等框架的组件），并将组件的状态和props注入，生成完整的HTML页面结构。

1.  **生成HTML响应**：

    -   服务器端渲染完成后，生成包含所有必需HTML、CSS（内联或链接样式表）和JavaScript（通常是打包好的bundle文件）的完整响应体，发送给客户端浏览器。

1.  **浏览器渲染**：

    -   浏览器接收到服务器返回的HTML响应后，迅速解析并渲染出页面，用户可以看到初步呈现的页面内容，搜索引擎爬虫也能抓取到有意义的HTML内容，这对SEO（搜索引擎优化）非常有利。

1.  **客户端接管**：

    -   页面在浏览器中加载完毕后，前端框架在客户端开始运行，通常会进行所谓的“hydration”（水合）过程，即将服务器生成的HTML标记转换为可交互的、由JavaScript驱动的组件树。
    -   此后，客户端接管页面交互和路由跳转，提供流畅的SPA体验。

服务端渲染的优点在于初次加载时能更快地呈现页面内容、利于SEO优化，同时也可以在弱网环境下改善用户体验。但同时，它也增加了服务器端的计算负担，并且在某些情况下，可能会增加首屏加载时的总体字节大小。


#### 浏览器页面渲染机制

https://juejin.cn/post/6844903426002780168

浏览器页面渲染机制是一个复杂的过程，主要包括以下几个关键步骤：

1.  **HTML解析**：

    -   浏览器首先接收到服务器返回的HTML文档，通过HTML解析器将其解析为DOM（Document Object Model）树。DOM树是一种结构化的表示，反映了HTML文档元素及其层级关系。

1.  **CSS解析**：

    -   同时，浏览器还会解析CSS（Cascading Style Sheets）资源，生成CSSOM（CSS Object Model）树。CSSOM描述了各元素应该如何显示，包括颜色、大小、布局等样式信息。

1.  **DOM与CSSOM合并**：

    -   DOM树和CSSOM树合并成Render Tree（渲染树），渲染树只包含可见元素以及与之相关的样式信息。在这个过程中，那些被CSS隐藏的元素（如`display:none`）不会出现在渲染树中。

1.  **Layout（布局）** ：

    -   根据渲染树中每个节点的计算样式，浏览器进行布局计算（也被称为“重排”或“回流”）。浏览器根据CSS盒模型和其他布局信息，确定每个节点在视口中的确切位置和大小。

1.  **Paint（绘制）** ：

    -   在布局完成后，浏览器按照渲染树从后往前进行绘制，也就是从最底层的背景色和图像开始，逐层绘制文本、边框以及其他可视内容。这个过程包括合成层的创建、栅格化和渲染。

1.  **Composite（合成）** ：

    -   对于那些拥有层叠上下文的元素，浏览器还会执行复合操作（Compositing），将独立图层合成为最终的页面图像。层叠上下文允许元素在Z轴方向上独立渲染，从而实现动画、透明度和其他高级效果。

1.  **更新与重绘**：

    -   当DOM或CSS发生变化时，部分或全部渲染流程需要重新执行，可能涉及局部或全局的重排、重绘和合成。现代浏览器尽可能优化这个过程，只重新渲染受影响的部分。

在整个渲染过程中，浏览器通常会尽可能地将工作推迟到下一帧的渲染周期，以此提高页面性能和响应速度。此外，像Chrome等现代浏览器还会利用硬件加速功能，通过GPU协助完成一些复杂的图形渲染操作。
https://juejin.cn/post/6844903815758479374

#### 重绘与回流

https://juejin.cn/post/7064077572132323365?searchId=2024041923035214807F0FC7DD82B16D97

在浏览器渲染过程中，重绘（Repaint）与重排（Reflow，也称为回流）是两种重要的更新机制，它们关乎页面性能和用户体验。

**重排（Reflow）** ：

-   当一个元素的几何属性（如宽、高、外边距、内边距、定位等）发生变化，或者DOM树结构发生改变（如新增、删除、移动DOM元素）时，浏览器需要重新计算元素及其相关联元素的布局和位置。这个过程涉及对渲染树中所有受影响元素重新布局，即重新计算它们的几何信息，这会触发回流操作。
-   回流不仅影响触发它的单个元素，还可能影响到周围布局，因为它可能导致整个文档流乃至整个视窗区域内的元素重新布局。
-   回流通常代价较高，因为它会引发一系列连锁反应，可能导致大量计算和渲染工作。

**重绘（Repaint）** ：

-   重绘则是指当元素的外观属性（如颜色、背景色、边框样式、背景图像等）发生变化，但元素的几何尺寸和位置没有改变时，浏览器仅需要更新屏幕上该元素的像素信息，而不必重新计算布局。
-   重绘比重排的性能开销较小，因为它不需要重新计算元素的布局，而是直接刷新屏幕上的某些像素区域。

**优化策略**： 由于重排和重绘会影响页面性能，特别是在大规模或频繁变动时，因此前端开发者应该尽量减少不必要的重排和重绘。可以通过以下方式来优化：

-   避免不必要的DOM操作，特别是改变元素几何属性的操作。
-   批量修改DOM和样式，而不是逐个修改。
-   使用CSS3 `transform` 和 `opacity` 属性进行动画，它们通常不会触发重排，而只会触发重绘或合成层更新。
-   利用硬件加速特性，减少CPU负担。

总之，在实际开发中，理解和掌握重排与重绘的触发条件及优化方法对于提升网页性能至关重要。


#### 浏览器的缓存策略

https://juejin.cn/post/6844903736196726798

浏览器缓存策略是浏览器为了提高网页加载速度和减少网络带宽消耗而采取的一种机制，它允许浏览器在满足一定条件时，直接从本地缓存中加载资源而不是重新向服务器请求。浏览器缓存策略主要分为两大类：强缓存和协商缓存。

**强缓存（也称为绝对缓存）** ：

-   **Expires**：服务器在响应头中设置一个到期时间，如果在这个时间内，浏览器认为缓存内容依然有效，则直接从缓存中加载资源，不再向服务器发送请求。
-   **Cache-Control**：优先级高于Expires，它支持更多的缓存指令，如`max-age`（指定缓存的有效时间，单位秒）、`no-cache`（要求验证缓存）、`no-store`（禁止缓存）等。

**协商缓存（也称为条件GET或对比缓存）** ：

-   **Last-Modified / If-Modified-Since**：服务器在响应头中添加`Last-Modified`表示资源最后修改时间，浏览器在下次请求时带上`If-Modified-Since`，询问服务器资源是否已更新，如果服务器确认资源未变化，则返回304 Not Modified，浏览器继续使用缓存中的资源。
-   **ETag / If-None-Match**：服务器为每个资源生成一个唯一的`ETag`（实体标签），浏览器请求时带上`If-None-Match`，询问服务器资源是否有新的ETag，如果没有变化，则返回304 Not Modified。

浏览器在发起请求时会先检查强缓存策略，如果强缓存未命中的情况下才会采用协商缓存策略。这两种策略结合使用，能够有效提高网页加载速度，减少不必要的网络传输，并保证在资源更新时及时获取最新版本。

#### 线程与进程
https://juejin.cn/post/6991849728493256741

https://juejin.cn/post/6844904050543034376

线程（Thread）和进程（Process）是操作系统中两种重要的抽象概念，它们都是实现并发和并行计算的基础单位，但有不同的层次和侧重点：

**进程**：

-   进程是操作系统资源分配和保护的基本单位，每个进程都有自己独立的地址空间，包含代码、数据、堆、栈等资源，以及打开的文件描述符、信号处理函数等系统资源。
-   进程之间是相互隔离的，也就是说，一个进程不能直接访问另一个进程的内存空间，若要通信，需要借助IPC（进程间通信）机制，如管道、消息队列、共享内存、套接字等。
-   操作系统调度的基本单位是进程，每个进程可以有多个线程，但至少有一个主线程。

**线程**：

-   线程是进程中执行运算的最小单位，是进程中实际运作的实体，它负责执行一系列指令序列。
-   线程共享进程的资源，如地址空间、全局变量、文件描述符等，因此多个线程可以访问相同的内存地址，但也需要同步机制防止数据竞争。
-   线程有自己的程序计数器、堆栈和局部变量，但在同一进程中的线程切换代价相比进程切换要小得多。
-   线程可以并发执行，即在一个进程中可以同时有两个或更多的线程在运行，从而提高程序的执行效率和响应速度。

简而言之，进程是资源拥有者，线程是资源使用者，线程是操作系统调度的更细粒度单元。多线程技术使得在一个进程中可以实现多个并发活动，充分利用CPU资源，而多进程技术则允许多个独立的任务同时在系统中运行。
##### 浏览器中的进程与线程
浏览器是一个包含多个进程和多个线程的复杂软件系统。浏览器本身是由多个进程构成的，而每个进程中又有多个线程协同工作。

-   **进程层面**： 浏览器通常会为每个打开的标签页、扩展或插件创建单独的进程，这样做的好处是提高了浏览器的稳定性，一个标签页或者插件崩溃不会影响其他标签页。例如，Google Chrome浏览器就采用了多进程架构，每个Tab页（或者其他独立的渲染上下文）都在各自的渲染进程中运行。

-   **线程层面**： 每个浏览器进程内部包含多个线程，例如：

    -   **GUI线程**：负责处理用户界面事件和渲染网页。
    -   **JS引擎线程**：负责执行JavaScript代码，由于JavaScript是单线程的，因此在单个JS上下文中执行JavaScript代码时，同一时间只能执行一段代码。
    -   **渲染线程**：负责解析HTML、CSS并将其渲染成可视界面，与JS引擎线程互斥。
    -   **网络线程**：处理HTTP请求和响应。
    -   **定时器线程**：处理setTimeout和setInterval等定时任务。
    -   **事件触发线程**：处理各种事件，如鼠标点击、键盘敲击、页面加载等。
    -   **音频、视频解码线程**：处理多媒体流的播放和解码。

总的来说，浏览器是一个多进程架构，每个进程内部又包含多个线程协同工作，以实现高效的并发处理和良好的用户体验。
##### JS与单线程

JavaScript引擎在浏览器中的执行确实是单线程的，即JavaScript代码在一个给定的上下文中（如浏览器Tab页）只能通过一个主线程执行。然而，浏览器本身并非单线程，它是一个多进程或多线程环境。具体到浏览器的一个Tab页，虽然JavaScript执行环境是单线程的，但浏览器为每个Tab页通常会分配一个渲染进程，这个进程中除了包含处理JavaScript的线程之外，还有其他的线程负责不同的任务，比如渲染线程、网络请求线程、事件处理线程等。

JavaScript在浏览器环境中的执行环境是单线程的，这主要是出于历史原因和安全性考虑，因为JavaScript最初设计是用来在浏览器中执行脚本，以增强网页的交互性，如果允许多个线程随意修改DOM，将会产生难以预料的结果和同步问题。

在JavaScript的单线程模型中，所有的任务（同步任务和异步任务）都放在一个执行栈（Call Stack）中按序执行。同步任务会按照代码的书写顺序逐个执行，而异步任务（如网络请求、定时器等）则会被放到任务队列（Task Queue）中，等待主线程空闲时（也就是执行栈为空时）通过事件循环（Event Loop）机制被推送到执行栈中执行。

异步编程模型通过回调函数、Promise、Generator函数（配合co模块或async/await）以及Async/Await等方式来实现非阻塞式的任务处理，使得即便在单线程环境下，JavaScript也能高效地处理异步任务而不阻塞UI线程，保持页面的响应性。

此外，为了更好地利用多核CPU资源，现代浏览器提供了Web Workers API，允许JavaScript在后台创建独立的工作者线程（Worker Threads），这些线程可以独立于主线程运行，执行计算密集型或I/O密集型任务，但它们不能直接操作DOM，而是通过消息传递与主线程通信。而对于Node.js环境，虽然其JavaScript运行环境也是单线程，但底层的V8引擎加上libuv库支持异步I/O操作，使其在处理I/O任务时能充分利用系统资源，表现出类似异步多线程的效果。

#### [事件循环机制](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Event_loop)
https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
https://juejin.cn/post/6914201197620494350

JavaScript事件队列（Event Queue）和事件循环（Event Loop）是JavaScript运行时环境（如浏览器环境）中处理异步任务的核心机制。JavaScript引擎是单线程的，这意味着在同一时间内只能执行一段代码。为了解决异步处理问题，引入了事件队列和事件循环机制。

**事件队列（Event Queue）** ： 事件队列是一个存放异步任务回调函数的有序列表。当JavaScript执行过程中遇到异步操作（如定时器、网络请求、I/O操作等）时，不会立即执行其结果处理函数，而是将其放到事件队列中排队等待。事件队列可以包含多个不同的队列，比如宏任务队列（Macro Task Queue）和微任务队列（Micro Task Queue）。

**宏任务（Macro Tasks）** ： 宏任务主要包括：

-   `setTimeout` 和 `setInterval` 回调函数
-   I/O 操作完成后触发的回调
-   UI 渲染完成后触发的回调（浏览器环境中）
-   `requestAnimationFrame` 回调
-   Node.js 中的 `setImmediate`

**微任务（Micro Tasks）** ： 微任务通常在当前宏任务执行完毕，但在下一个宏任务执行之前执行，优先级更高，主要包括：

-   `Promise` 的 `.then`、`.catch` 和 `.finally` 方法注册的回调
-   MutationObserver 的回调
-   `queueMicrotask` 函数注册的回调

**事件循环（Event Loop）** ： 事件循环机制是不断监控和协调事件队列和执行栈的过程。它的工作流程如下：

1.  执行全局脚本或调用栈中的同步代码。
1.  当调用栈为空时，检查微任务队列是否有待执行的任务，如果有，则取出并执行所有微任务。
1.  执行完所有微任务后，开始执行下一个宏任务。
1.  宏任务执行完毕后再次回到第二步，检查微任务队列。
1.  如此反复循环，直至事件队列为空。

举例说明：

```
Javascript
console.log('1');

setTimeout(() => {
  console.log('2');
});

new Promise((resolve) => {
  resolve();
}).then(() => {
  console.log('3');
});

console.log('4');
```

在上述代码中，同步代码首先执行，输出'1'和'4'。随后，`setTimeout`注册的宏任务被放入宏任务队列，`Promise`的`.then`方法注册的微任务被放入微任务队列。在本次事件循环中，同步代码执行完毕后，立即执行微任务队列中的所有任务，输出'3'。接下来的一个事件循环轮询中，才会执行宏任务队列中的`setTimeout`回调，输出'2'。

这种事件驱动的异步模型保证了JavaScript引擎在处理异步任务时既能保持单线程执行，又能实现异步处理，使得Web应用能够在等待异步操作的同时处理用户交互和其他同步任务。

#### CDN

https://juejin.cn/post/6844903460828086285

内容分发网络（Content Delivery Network, CDN）是一种分布式网络服务，旨在通过在全球范围内设立多个边缘服务器节点，将网站内容和服务（如静态网页、图片、视频、脚本等）缓存并分发到接近用户的地理位置。当用户访问网站时，CDN会将请求引导至最近的边缘服务器，从而大幅缩短数据传输距离，提高内容加载速度，优化用户体验，减轻源站服务器的压力，并提高网站的可用性和扩展性。

使用CDN的主要原因包括：

1.  **提高内容加载速度**：通过减少内容传输距离，降低网络延迟，从而提升用户访问速度，尤其是对于多媒体内容丰富的网站或面向全球用户的网站。
1.  **缓解源站服务器压力**：CDN节点承担了大部分静态内容的分发任务，使得源站服务器不必处理所有用户的请求，从而降低了服务器负载，提高了网站的并发处理能力。
1.  **提高可用性和容灾能力**：由于CDN节点分散在多地，即使某个数据中心或网络出现故障，其他节点仍能继续提供服务，确保网站内容始终可访问。
1.  **节省带宽成本**：通过缓存和就近分发，减少了跨国或跨地区的大流量数据传输，可以显著降低源站的带宽费用。
1.  **防DDoS攻击**：CDN自带一定的流量清洗和负载均衡能力，能在一定程度上抵御分布式拒绝服务（DDoS）攻击，保护源站服务器不受攻击影响。
1.  **SEO优化**：页面加载速度是搜索引擎排名因素之一，CDN可以提升网站性能，有利于搜索引擎优化（SEO）。

综上所述，CDN成为了现代互联网基础设施中不可或缺的部分，对于提升网站性能、保证服务质量、节约成本等方面都有重要意义。

#### DNS
DNS（Domain Name System，域名系统）是一种分布式数据库服务，用于将易于记忆的域名（如www.example.com）转换为计算机网络中用于寻址的IP地址（如192.0.2.1）。DNS使得用户和应用程序无需记住复杂的数字IP地址，只需通过简洁易读的域名即可访问互联网上的资源。

使用DNS的原因主要包括：

1.  **人机友好性**：域名系统提供了一种更为人性化的方式来标识互联网上的服务器和网络资源，便于用户记忆和输入。
1.  **路由与寻址**：在互联网中，数据包的传输依赖于IP地址。DNS充当了桥梁，将人们熟知的域名转化为机器可以理解的IP地址，使得数据可以从源主机准确地送达目标主机。
1.  **负载均衡与冗余**：DNS可以通过记录（RR, Resource Records）的轮询、权重分配或其他智能调度策略，将用户请求导向不同服务器，实现负载均衡，同时提供冗余以防止单点失效。
1.  **分布式管理**：DNS采用分布式数据库架构，允许域名所有权人将域名管理权分散在世界各地的DNS服务器上，提高了整个互联网的稳定性和可靠性。
1.  **安全与认证**：DNS还支持DNSSEC等安全扩展，可以对域名数据进行签名以防止中间人攻击和域名劫持，从而加强互联网的安全性。

因此，DNS是互联网运作的基础服务之一，它确保了用户能够便捷、准确且高效地访问全球范围内的网络资源。

#### HTTP状态码
HTTP状态码（HTTP Status Codes）是HTTP协议中用于表示服务器对客户端请求的响应状态的标准格式代码，通常是一个三位数字。这些状态码对客户端和服务器之间的通信有着重要的指示作用，帮助开发者和用户理解请求是否成功、为何失败以及下一步应该做什么。以下是HTTP状态码的主要分类和部分常见状态码及其含义：

1.  **1XX（临时响应）** ：信息性状态码，表示服务器正在处理请求，但尚未完成。

    -   `100 Continue`：客户端可以继续发送请求正文。
    -   `101 Switching Protocols`：服务器正在切换协议。

1.  **2XX（成功）** ：表示请求已经被成功接收、理解和接受。

    -   `200 OK`：请求成功，请求的数据或操作成功完成。
    -   `201 Created`：请求已被成功处理，并创建了新资源。
    -   `202 Accepted`：服务器已接受请求，但还未处理完成。
    -   `204 No Content`：请求成功，但响应体不包含任何内容。

1.  **3XX（重定向）** ：需要进一步操作才能完成请求。

    -   `301 Moved Permanently`：被请求的资源已永久移动到新位置。
    -   `302 Found` 或 `307 Temporary Redirect`：临时重定向，资源暂时存在于不同的URI下。
    -   `303 See Other`：请求应当使用 GET 方法获取另一个 URI 上的资源。
    -   `304 Not Modified`：客户端缓存依然有效，服务器未对资源内容做出修改。

1.  **4XX（客户端错误）** ：客户端似乎发生了错误。

    -   `400 Bad Request`：服务器无法理解请求，可能是由于格式错误等原因。
    -   `401 Unauthorized`：请求未经授权，需要提供有效的身份验证凭证。
    -   `403 Forbidden`：服务器理解请求，但拒绝执行它。
    -   `404 Not Found`：服务器找不到请求的资源。
    -   `405 Method Not Allowed`：请求方法（如 POST、PUT 等）不被允许。

1.  **5XX（服务器错误）** ：服务器遇到了意外情况，无法完成请求。

    -   `500 Internal Server Error`：服务器遇到了未知错误，无法完成请求。
    -   `501 Not Implemented`：服务器不支持请求的功能。
    -   `502 Bad Gateway`：作为网关或代理工作的服务器收到了无效响应。
    -   `503 Service Unavailable`：服务器当前无法处理请求，通常由于服务器过载或维护。
    -   `504 Gateway Timeout`：作为网关或代理工作的服务器未及时从上游服务器收到请求。

每一种状态码都有其特定的意义，有助于客户端和服务器之间进行有效的通信和错误处理。
#### POST和GET
https://juejin.cn/post/6844903508370538503
#### HTTP报文
HTTP（HyperText Transfer Protocol，超文本传输协议）报文是HTTP协议中客户端与服务器之间进行通信的数据块，它包括请求报文和响应报文两种类型，每种类型的报文都有其特定的结构。

**HTTP 请求报文结构**：

1.  **请求行（Request Line）** ：

    -   包括请求方法（如GET、POST、PUT、DELETE等）、请求URI（Uniform Resource Identifier）和HTTP版本号。
    -   示例：`GET /index.html HTTP/1.1`

1.  **请求头（Request Headers）** ：

    -   一系列键值对，用于提供有关请求的附加信息，如客户端信息（User-Agent）、接受类型（Accept）、内容长度（Content-Length）、授权信息（Authorization）等。

    -   示例：

        ```
        Code
        Host: example.com
        Accept-Language: en-US,en;q=0.5
        Content-Type: application/x-www-form-urlencoded
        ```

1.  **空行（Blank Line）** ：

    -   请求头和请求正文之间有一个空行（CRLF，即回车换行）用于区分两者。

1.  **请求正文（Request Body，可选）** ：

    -   若请求方法允许或需要携带请求数据（如POST、PUT请求），则在空行之后跟随的就是请求正文，用于承载具体的请求内容，如表单数据、JSON、XML等。

**HTTP 响应报文结构**：

1.  **状态行（Status Line）** ：

    -   包括HTTP版本号、状态码（如200、404、500等）和状态消息（Reason-Phrase）。
    -   示例：`HTTP/1.1 200 OK`

1.  **响应头（Response Headers）** ：

    -   类似于请求头，包含服务器相关信息，如服务器类型（Server）、内容类型（Content-Type）、内容长度（Content-Length）、缓存控制（Cache-Control）等。

    -   示例：

        ```
        Code
        1Server: Apache/2.4.1
        2Content-Type: text/html; charset=UTF-8
        3Content-Length: 1234
        ```

1.  **空行（Blank Line）** ：

    -   响应头和响应正文之间同样有一个空行（CRLF）作为分隔。

1.  **响应正文（Response Body，可选）** ：

    -   包含服务器返回给客户端的数据，可以是HTML文档、JSON数据、图片或其他任何类型的数据。

总体来看，HTTP报文的结构清晰明了，方便客户端和服务器进行通信交互。对于每个报文，起始行和头部信息是必不可少的，正文则根据请求或响应的具体需求来确定是否存在。随着HTTP协议的发展，报文结构在不同版本中有所扩展，但基本框架保持一致。

#### TCP三次握手与四次挥手
TCP（Transmission Control Protocol）是一种面向连接的、可靠的传输层协议，在网络通信中确保数据的可靠传输。TCP建立连接和断开连接分别经历了著名的“三次握手”(Three-Way Handshake) 和“四次挥手”(Four-Way Handshake) 过程。

##### 三次握手 (Three-Way Handshake)

1.  **第一次握手 (SYN)** :

    -   客户端想要与服务器建立连接时，它会随机生成一个初始序列号（ISN），然后发送一个SYN（同步序列编号Synchronize Sequence Numbers）报文段给服务器。这个报文段中包含客户端的初始序列号（seq = x）。

    ```
    Code
    1客户端 -> 服务器: SYN(seq=x)
    ```

1.  **第二次握手 (SYN + ACK)** :

    -   服务器接收到客户端的SYN报文段后，确认客户端发起连接请求，并且也随机生成自己的初始序列号（ISN）。服务器返回一个SYN报文段的同时携带一个ACK（确认Acknowledgement）报文段，其中确认号ack设置为x+1（即客户端的序列号加1），表示已经收到了客户端的SYN；同时带上自己的序列号seq=y。

    ```
    Code
    1服务器 -> 客户端: SYN(seq=y), ACK(ack=x+1)
    ```

1.  **第三次握手 (ACK)** :

    -   客户端收到服务器的SYN+ACK报文段后，需要对服务器的SYN进行确认。因此，客户端再次发送一个ACK报文段，确认号ack设置为y+1（即服务器的序列号加1），表示已收到服务器的SYN。至此，双方都已确认对方的初始序列号，且都知道对方已准备好建立连接。

    ```
    Code
    1客户端 -> 服务器: ACK(ack=y+1)
    ```

经过这三次握手之后，客户端和服务器就建立了可靠的TCP连接，可以开始传输数据。

##### 四次挥手 (Four-Way Handshake)

1.  **第一次挥手 (FIN)** :

    -   当某一方（例如客户端）完成数据传输任务或者打算关闭连接时，它会向另一方（例如服务器）发送一个FIN（结束Finish）报文段，请求关闭从客户端到服务器的数据传输通道。此时，客户端进入FIN_WAIT_1状态。

    ```
    Code
    1客户端 -> 服务器: FIN(seq=u)
    ```

1.  **第二次挥手 (ACK)** :

    -   服务器接收到客户端的FIN报文段后，确认该请求，此时服务器知道客户端不再有新的数据发送过来，但仍可能继续向客户端发送数据。服务器回应一个ACK报文段，确认号ack设置为u+1，表示已收到客户端的FIN。服务器进入CLOSE_WAIT状态，而客户端进入FIN_WAIT_2状态。

    ```
    Code
    1服务器 -> 客户端: ACK(ack=u+1)
    ```

1.  **第三次挥手 (FIN)** :

    -   服务器完成所有数据的发送后，也会发送一个FIN报文段给客户端，请求关闭从服务器到客户端的数据传输通道。

    ```
    Code
    1服务器 -> 客户端: FIN(seq=v), ACK(ack=u+1)
    ```

1.  **第四次挥手 (ACK)** :

    -   客户端接收到服务器的FIN报文段后，同样发送一个ACK报文段作为回应，确认号ack设置为v+1，表示已收到服务器的FIN。此时，客户端等待一段时间（通常称为TIME_WAIT状态，防止最后确认报文段在网络中丢失）后彻底关闭连接。服务器在接收到客户端的ACK后立即关闭连接。

    ```
    Code
    1客户端 -> 服务器: ACK(ack=v+1)
    ```

以上就是TCP连接建立与终止过程中的三次握手与四次挥手的详细描述。这些机制确保了数据传输的可靠性和连接的有序建立与释放。

#### HTTP3

https://juejin.cn/post/6844903489596833800
HTTP/1.x、HTTP/2 和 HTTP/3 是超文本传输协议（HTTP）的三个主要版本，各自有显著的特点和改进之处。下面是这三个版本之间主要的区别：

**HTTP/1.x**

-   **特点**：

    -   HTTP/1.0 和 HTTP/1.1 是广泛应用的传统版本。
    -   HTTP/1.1 引入了持久连接（Persistent Connections），允许在一个TCP连接上发送多个HTTP请求和响应，但存在队头阻塞（Head of Line Blocking）问题，即一个请求的响应必须等待前面请求完成才能开始传输。
    -   HTTP/1.1 还增加了缓存控制、分块传输编码、host头部字段等改进。

**HTTP/2**

-   **特点**：

    -   HTTP/2 最大的改进是引入了多路复用（Multiplexing），允许在一个TCP连接上并行处理多个请求和响应，解决了HTTP/1.x中的队头阻塞问题，大幅度提升了页面加载速度。
    -   HTTP/2 使用二进制分帧（Binary Framing），将HTTP消息分解为更小的帧，提高了协议解析效率和灵活性。
    -   头部压缩（Header Compression），通过HPACK算法对请求和响应头部进行压缩，减少不必要的网络传输量。
    -   服务器推送（Server Push），服务器可以在客户端请求前主动推送相关资源。

**HTTP/3**

-   **特点**：

    -   HTTP/3 最大的变化是抛弃了TCP，转而基于QUIC协议，QUIC是一种基于UDP的可靠传输协议，集成了TLS加密，实现了更低的延迟和更快的连接建立。
    -   保留了HTTP/2的多路复用优势，但基于QUIC的多路复用机制更加强大，因为它在传输层就已经支持多路复用，而且具备快速恢复机制，对丢包有更好的应对能力。
    -   由于QUIC内置了TLS加密，HTTP/3比HTTP/2的加密传输速度更快，且更安全。

总结来说，HTTP/2 和 HTTP/3 都致力于提高网络性能，减少延迟，而HTTP/3在HTTP/2的基础上进一步改进了传输层的性能和安全性。

#### 客户端识别与cookie机制

https://juejin.cn/post/6844904115080790023

客户端识别是Web应用程序和服务识别和追踪用户会话的过程。在HTTP协议中，由于其原始设计是无状态的，这意味着服务器在处理完客户端的一次请求后，如果不借助额外的机制，无法关联到后续的请求。为了弥补这一缺陷，Cookie机制应运而生，用于维持客户端与服务器之间某种形式的状态。

**Cookie机制**：

1.  **工作原理**：

    -   当客户端首次向服务器发起请求时，服务器可以根据业务逻辑创建一个Cookie，并通过HTTP响应头`Set-Cookie`将其发送给客户端。
    -   客户端收到Cookie后，将其保存在本地（浏览器的Cookie存储区）。
    -   之后客户端每次向同一服务器发起请求时，都会自动在HTTP请求头`Cookie`中带上之前服务器设定的Cookie。
    -   服务器通过检查请求头中的Cookie信息，就可以识别出客户端的身份和相关的会话状态。

1.  **Cookie属性**：

    -   Cookie可以包含多种属性，如`expires`（生命周期）、`path`（作用路径）、`domain`（作用域域名）、`secure`（仅在HTTPS下传输）、`HttpOnly`（禁止JavaScript访问该Cookie）等。
    -   `SameSite`属性用于限制第三方Cookie的发送策略，以增强安全性。

1.  **跨站请求（CORS）与Cookie**：

    -   当涉及到跨域资源共享（CORS）时，`crossorigin`属性可以用来指示是否允许跨域访问Cookie，以及是否需要发送认证信息。
    -   `anonymous`表示在跨域请求时不携带验证信息，而`use-credentials`则表示携带验证信息，如Cookie。

1.  **安全性**：

    -   使用Cookie进行客户端识别时，需注意隐私和安全问题，不应滥用Cookie来追踪用户的行为，特别是在没有明确告知用户和获得同意的情况下。
    -   使用`Secure`和`HttpOnly`属性可以帮助增加Cookie的安全性，防止恶意脚本盗取或篡改Cookie信息。

1.  **替代方案**：

    -   除了Cookie以外，还有其他客户端识别的技术，如Token-based身份验证（JWT、OAuth等），或者利用HTML5的localStorage和sessionStorage等Web Storage技术进行客户端状态管理。

总之，Cookie机制在客户端识别和会话管理中扮演着核心角色，允许Web应用程序维持状态并个性化用户交互。但同时也伴随着一定的安全风险和隐私考虑，因此在实际应用中需要谨慎设计和使用。
#### 代理服务器与反向代理以及负载均衡
**代理服务器（Proxy Server）** ： 代理服务器作为一个中间层，主要用于客户端与服务器之间的通信。当客户端发起请求时，请求首先被发送到代理服务器，代理服务器接收到请求后，根据配置决定是否直接将请求传递给目标服务器，或者根据其他条件（如缓存策略）处理请求。代理服务器可以用于：

1.  **匿名访问**：通过隐藏客户端的IP地址，保护用户隐私。
1.  **缓存服务**：代理服务器可以缓存常用或静态资源，减少对目标服务器的请求次数，提高访问速度。
1.  **访问控制**：企业或组织可以设置代理服务器，对内部网络用户的互联网访问行为进行管理和限制。
1.  **内容过滤**：可以过滤或阻止访问某些不安全或不适合的网站内容。

**反向代理（Reverse Proxy）** ： 反向代理与代理服务器相反，它位于服务器端，对外面的客户端而言就像是实际的服务端。客户端直接向反向代理服务器发送请求，反向代理服务器负责将请求转发到内部的后端服务器群，并将后端服务器的响应返回给客户端。反向代理的主要作用包括：

1.  **负载均衡**：通过转发机制将请求分发到多个后端服务器，平衡服务器负载，提高系统整体性能和可用性。
1.  **安全防护**：隐藏真实服务器地址，提供额外的安全屏障，如WAF（Web应用防火墙）功能，抵挡DDoS攻击等。
1.  **内容缓存**：对一些静态或不太频繁变化的内容进行缓存，减轻后端服务器压力。
1.  **统一入口点**：简化网络架构，提供统一的接入点，便于管理和维护。

**负载均衡（Load Balancing）** ： 负载均衡是一种服务器集群管理技术，目的是在多台服务器间分配网络负载，以确保服务的高性能、高可用性和可扩展性。反向代理常常与负载均衡相结合，通过一定的策略（如轮询、最少连接数、权重分配等）将客户端请求分配给后端服务器集群中的某一节点。这样，即使在高并发情况下，也能保证服务的稳定性和响应速度。

总结来说，代理服务器和反向代理分别从客户端和服务器端的角度出发，实现不同的功能，而反向代理经常作为负载均衡解决方案的一部分，用于优化服务器集群的性能和可用性。

#### 正则表达式
正则表达式（Regular Expression，简称regex或regexp）是一种强大而灵活的文本处理工具，它是一种模式匹配语言，用于描述和匹配字符串中的字符组合。正则表达式被广泛应用于各种编程语言和文本处理软件中，用于搜索、替换、分割文本，以及验证字符串是否符合特定格式。

正则表达式的组成部分通常包括：

1.  **元字符**：如`.`（匹配任意单个字符，除换行符外）、`\d`（匹配数字）、`\w`（匹配字母、数字或下划线）、`\s`（匹配空白字符）等。
1.  **量词**：如`*`（零次或多次）、`+`（一次或多次）、`?`（零次或一次）、`{m,n}`（m到n次）等，用来描述前面元素的重复次数。
1.  **字符类**：方括号`[]`用于定义一组可选字符，如`[abc]`匹配'a'、'b'或'c'。
1.  **分组和引用**：圆括号`()`用于分组，同时也可以用于后向引用或捕获组。如`(\w+)\s+\1`会匹配连续的两个相同的单词。
1.  **边界匹配**：如`^`匹配字符串的开始，`$`匹配字符串的结束，`\b`匹配单词边界。
1.  **选择和排除**：竖线`|`用于提供选择项，`[^abc]`表示匹配除'a'、'b'和'c'之外的任何字符。
1.  **预定义字符类**：例如`\d`（数字）、`\D`（非数字）、`\w`（单词字符）、`\W`（非单词字符）、`\s`（空白字符）、`\S`（非空白字符）等。

正则表达式的例子：

-   `/^\d{3}-\d{2}-\d{4}$/` 匹配美国社保号码格式（如123-45-6789）。
-   `/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.[a-zA-Z]{2,}$/` 匹配电子邮件地址格式。

在实际编程中，正则表达式通常与字符串函数结合使用，如搜索（search）、替换（replace）、split等操作。在JavaScript中，你可以使用`RegExp`对象或字符串的原生方法来处理正则表达式。在Python、Java、Perl、PHP等其他语言中也有对应的正则表达式支持。
#### 前端性能优化

https://juejin.cn/post/6892994632968306702


### web安全

#### 常见的加密方式
1.  **对称加密算法**：

    -   **DES (Data Encryption Standard)** ：早期的数据加密标准，现在由于密钥长度较短，已逐渐被淘汰。
    -   **3DES (Triple DES)** ：DES的增强版，通过三次DES加密来提高安全性。
    -   **AES (Advanced Encryption Standard)** ：当前广泛使用的对称加密标准，提供了更好的性能和安全性，密钥长度有128位、192位和256位三种规格。
    -   **Blowfish、RC2、RC4、RC5、IDEA**：这些都是其他曾经或仍在某些场景下使用的对称加密算法。

1.  **非对称加密算法**：

    -   **RSA**：最为广泛使用的非对称加密算法，常用于密钥交换、数字签名等场景。
    -   **Elgamal**：也是一种公钥加密算法，不过不如RSA应用得那么普遍。
    -   **ECC (Elliptic Curve Cryptography)** ：椭圆曲线密码学，相比RSA在相同的安全等级下所需密钥长度较小，因此更适合资源受限的设备。
    -   **Diffie-Hellman Key Exchange**（DHKE）：用于安全地在不安全的信道上协商共享密钥。

1.  **哈希算法**：

    -   **MD5**：虽然已知存在碰撞问题，但因其速度快，仍偶尔用于简单数据完整性校验。
    -   **SHA-1**：安全性较低，但仍有少量使用场景，已被更安全的SHA-2系列取代。
    -   **SHA-256、SHA-384、SHA-512**：SHA-2系列的安全性较高，被广泛用于消息摘要、数字签名、密码哈希等场景。
    -   **bcrypt、scrypt**：专门设计用于密码哈希的算法，增加了抗暴力破解的能力。

1.  **消息认证码(MAC)与HMAC**：

    -   **HMAC**：基于哈希函数和密钥的认证码，用于确保消息完整性和真实性。

1.  **数字签名算法**：

    -   **RSA签名**：使用RSA非对称加密算法实现数字签名。
    -   **ECDSA**：基于椭圆曲线的数字签名算法，相较于RSA签名在同等安全级别下，能够使用更短的密钥。

1.  **TLS/SSL**：

    -   **TLS（Transport Layer Security）** ：前身是SSL（Secure Sockets Layer），用于加密网络通信，如HTTPS，结合了对称加密、非对称加密、哈希算法等多种加密技术。

1.  **WebCrypto API**：

    -   现代浏览器提供的Web Crypto API，允许JavaScript在浏览器端执行加密操作，支持多种加密、解密、哈希、签名等操作。

1.  **其他加密技术**：

    -   **Web Storage加密**：如Local Storage、Session Storage中的数据加密。
    -   **Web Workers加密**：在Web Workers中进行加密运算以避免阻塞主线程。
    -   **Web Cryptography API**：提供了更多现代加密算法和操作，如AES-GCM、HKDF等。

以上提及的加密方式只是众多加密技术中的一部分，每种加密技术都有其适用场景和安全考量。在实际应用中，根据需求和安全等级选择合适的加密算法和方案至关重要。
#### Web爬虫
Web爬虫（Web Crawler），又称网页爬虫、网络爬虫或蜘蛛（Spider）、机器人（Robot），是一种自动在网络上爬取和抓取网页信息的程序。它依据预设的规则，沿着网页中的超链接从一个网页爬行到另一个网页，持续不断地抓取网页内容，并对其进行分析和存储。

Web爬虫的工作原理通常包括以下步骤：

1.  **初始化**：爬虫从种子URL（通常是用户指定的起始网址）开始启动。
1.  **下载网页**：通过HTTP(S)协议向服务器发送请求，下载网页HTML内容或其他格式的数据。
1.  **解析内容**：下载后的网页内容通过HTML解析器解析，提取出其中的超链接和其他感兴趣的信息，如文本、图片、视频等。
1.  **数据抽取**：根据预先设定的规则，抽取有用的数据并进行清洗、整理。
1.  **去重**：为了避免重复抓取相同的网页内容，爬虫会使用URL去重策略，如布隆过滤器（Bloom Filter）或集合存储已抓取过的URL。
1.  **跟踪链接**：从当前网页中提取出新的链接，并将它们加入待抓取队列，继续遍历和抓取网页。
1.  **数据存储**：将抓取到的数据存储在本地数据库、文件或云端存储系统中，以便后续分析或使用。

Web爬虫的应用广泛，包括但不限于：

-   **搜索引擎构建**：搜索引擎通过大规模爬虫抓取互联网上的网页内容，并建立索引供用户搜索。
-   **市场调研**：用于收集竞争对手的产品信息、价格变动等商业情报。
-   **大数据分析**：获取大量数据用于科学研究、社会调查、舆情分析等领域。
-   **内容聚合**：新闻聚合、社交媒体监测等应用需要定期抓取目标网站的内容更新。

值得注意的是，在使用Web爬虫时，必须遵守法律法规，尊重网站的Robots协议（robots.txt），合理安排爬取频率，避免给目标服务器带来过大负担，同时保护用户隐私和个人数据安全。否则可能会触犯法律或道德规范。
#### 浏览器设备指纹
浏览器设备指纹（Browser Fingerprinting）是一种追踪和识别用户浏览器的技术，它通过收集浏览器和设备的各种独特特性，组合形成一个相对稳定的标识符，类似于人的指纹一样，可用于识别和区分不同的浏览器实例，即使用户清除了 cookies 或启用了隐私模式。

浏览器设备指纹包括但不限于以下信息：

1.  浏览器基本信息：如浏览器类型、版本、引擎、插件列表等。
1.  设备特性：屏幕分辨率、颜色深度、可用字体、时区、语言设置、CPU核心数、GPU信息等。
1.  浏览器能力测试结果：如对HTML5特性的支持程度、Canvas渲染的哈希值、WebGL指纹等。
1.  用户行为特征：如滚动条行为、鼠标移动轨迹等非硬性特征，有时也被用于丰富设备指纹。
1.  网络信息：IP地址、浏览器报告的时区、浏览器发出的HTTP请求头信息等。

通过这些信息的组合，网站和广告服务商可以构建一个足够独特的“指纹”，即使用户在不登录的情况下也能大致识别其身份，从而实现用户追踪、广告定向投放、防止欺诈行为等功能。然而，这种方法对用户隐私造成了很大威胁，因为即便用户尝试隐匿自己的线上行为，也可能因设备指纹的独特性而被识别出来。

随着用户隐私意识的提高和技术的进步，一些现代浏览器已经开始实施反指纹技术，限制或混淆对外提供的设备信息，以增强用户的隐私保护。同时，也有一些浏览器插件和隐私工具可以帮助用户对抗设备指纹追踪。
#### [HTTPS](https://tongyi.aliyun.com/qianwen/?spm=5176.28326591.0.0.40f76ee1dG3FZ2&sessionId=669f9c3b3bd940e1a0c538323dd20656)
HTTPS（全称 HyperText Transfer Protocol Secure）是一种网络安全协议，它在HTTP（超文本传输协议）的基础上通过SSL/TLS（安全套接字层/传输层安全）协议对通信内容进行加密，从而提供一个安全的通信通道。HTTPS 主要解决的问题包括：

1.  **数据加密**：在客户端和服务器之间传输的数据会被SSL/TLS协议加密，这意味着即使数据在传输过程中被第三方截获，也不能直接解读其内容，从而保护了用户的隐私信息，如登录凭据、信用卡号、个人通信内容等。
1.  **身份验证**：HTTPS不仅加密数据，还通过SSL证书对服务器的身份进行验证，确保用户访问的是预期的真实网站，而不是假冒的钓鱼网站。服务器会向客户端出示由受信任的证书颁发机构签发的SSL证书，证书中包含了服务器的身份信息，浏览器通过验证证书来确认服务器身份。
1.  **完整性校验**：HTTPS协议还能确保数据在传输过程中不被篡改，通过散列算法和消息认证码（MAC）等机制来校验数据的完整性。

因此，使用HTTPS的原因主要包括：

-   **保护隐私**：对敏感信息进行加密，防止中间人攻击和窃听。
-   **防止篡改**：确保数据在传输过程中未经非法改动。
-   **身份验证**：增强用户对网站的信任度，避免欺诈和钓鱼攻击。
-   **搜索引擎优化**：现代搜索引擎倾向于优先收录和展示使用HTTPS的网站。
-   **法律合规**：许多法规要求在处理用户个人信息时必须采用安全传输机制，HTTPS是满足这一要求的有效手段。

总结来说，HTTPS是构建可信、安全互联网的重要基石，广泛应用于电子商务、银行、社交网络等多个领域，以保障用户数据安全和隐私权益。

#### 浏览器安全

##### 同源策略
浏览器同源策略（Same-Origin Policy, SOP）是浏览器为保证用户信息安全和阻止恶意行为而实施的一种核心安全策略。同源策略规定了来自同一来源（协议、域名和端口均相同）的文档、脚本或样式表之间可以自由交互，而不同源的资源则有着严格的访问限制。

白帽黑客在讨论Web安全时，会强调同源策略在浏览器安全中的重要作用，因为它主要体现在以下几个方面：

1.  **数据隔离**：

    -   同源策略禁止一个网页通过脚本（如JavaScript）直接访问或修改另一个不同源网页的DOM结构和cookie等数据，除非该网页显式设置了CORS（跨源资源共享）策略允许特定源的访问。

1.  **防止恶意注入**：

    -   同源策略防止恶意网站通过iframe、script标签等方式嵌入其他网站的内容，并试图从中窃取或篡改数据，降低了XSS（跨站脚本攻击）和CSRF（跨站请求伪造）等攻击的风险。

1.  **资源加载限制**：

    -   不同源的图片、样式表和脚本等资源可以被加载，但脚本不能读取这些资源的内容，除非资源明确设置了Access-Control-Allow-Origin头部允许跨域访问。

1.  **API访问控制**：

    -   许多浏览器提供的API（如LocalStorage、IndexedDB、Cookies、XMLHttpRequest、Fetch等）也都遵循同源策略，限制了不同源之间对这些API数据的读写访问。

在实践中，白帽黑客会在评估Web应用安全性时关注同源策略的正确实施，以及如何利用现有的安全机制（如CORS、Content Security Policy等）来强化同源策略的限制，以防止因同源策略漏洞引发的安全风险。同时，他们也会研究绕过同源策略的攻击技术和防御措施，帮助开发者更好地理解并修复这类潜在的安全隐患。

##### 浏览器沙箱
浏览器沙箱（Browser Sandbox）是一种安全技术，它在浏览器内部创建了一个隔离的执行环境，使得在该环境中运行的网页内容（尤其是JavaScript脚本）无法直接访问或修改主机系统的底层资源，如文件系统、操作系统核心、硬件设备等。通过沙箱机制，浏览器确保了即便网页中包含恶意代码或存在安全漏洞，也不会对用户的计算机系统造成严重的损害。

浏览器沙箱的核心工作原理如下：

1.  进程隔离：现代浏览器如Google Chrome和Mozilla Firefox通常为每一个网页标签页或iframe创建独立的进程，各个进程之间的内存和资源是相互隔离的。
1.  权限限制：在沙箱内部运行的脚本仅被赋予有限的一组权限，例如只能访问有限的API，不允许直接进行文件操作或网络请求（除非用户明确授权或通过CORS等机制合法授权）。
1.  安全边界：浏览器通过对系统调用级别的控制，限制了沙箱内代码访问非授权资源的能力，即便代码试图执行危险操作，也会被浏览器的安全机制拦截或忽略。
1.  内存管理：浏览器对分配给沙箱环境的内存进行严格管理，一旦沙箱进程结束，其所占用的内存将被回收，避免持久化恶意代码或泄露用户数据。

通过这样的机制，浏览器沙箱有效地减少了因网页中潜在恶意代码而导致的安全风险，增强了用户浏览网页的安全性。
#### XSS
XSS（Cross-Site Scripting，跨站脚本攻击）是一种常见的Web应用程序安全漏洞，它允许攻击者在受害者浏览器中注入恶意脚本，这些脚本在用户浏览网页时被执行，可能导致诸如账户劫持、隐私数据泄露、恶意操作用户账号、重定向到恶意网站等各种安全问题。

XSS攻击主要有三种类型：

1.  **反射型XSS（Reflected XSS）** ：

    -   攻击者通过构造带有恶意脚本的URL，诱导受害者点击。当服务器接收到请求后，未经过滤直接将攻击脚本回显在响应页面中，导致受害者的浏览器执行了这段脚本。

1.  **存储型XSS（Stored XSS）** ：

    -   攻击者将恶意脚本提交到Web应用的数据库中，例如在论坛、博客评论区等地方发布包含恶意脚本的内容。当其他用户查看含有恶意脚本的内容时，他们的浏览器会执行这段脚本。

1.  **DOM-Based XSS（基于DOM的XSS）** ：

    -   这种类型的XSS并不依赖服务器回显数据，而是由于客户端JavaScript代码在处理来自不可信源的数据时未能妥善过滤或转义，直接将数据插入到网页的DOM（文档对象模型）中，导致恶意脚本被执行。

预防XSS攻击的主要措施包括：

-   **输入验证和净化**：对用户提交的所有数据进行严格的过滤和转义，确保输出到页面时不会构成有效的JavaScript代码。
-   **HTTP响应头设置**：使用HTTP响应头如`Content-Security-Policy`（CSP）来限制脚本的来源，只允许执行信任源的脚本。
-   **输出编码**：在向浏览器输出数据时，确保对特殊字符进行适当的HTML实体编码，防止被解释为HTML或JavaScript代码。
-   **安全编程实践**：在处理DOM时，确保对来自不可信源的数据进行清理或使用安全的API方法插入到DOM中。

总之，XSS攻击是对用户数据和隐私安全的巨大威胁，Web应用程序开发者应时刻关注并采取措施防止此类漏洞的发生。
#### CSRF
CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种网络攻击手段，攻击者利用网站对用户Cookie或其他认证信息的信任，诱使已登录用户在不知情的情况下执行非本意的操作，从而达到攻击目的。

攻击原理：

1.  用户A在浏览器中登录了某网站，并获得了该网站的Cookie（或者其他认证信息）用于标识身份。
1.  攻击者B构建一个恶意网页，其中包含一个针对该网站的请求（比如转账、发表文章、修改密码等），并将这个请求伪装成正常请求，如通过隐藏的表单提交或者Ajax请求。
1.  当用户A在不知情的情况下访问了攻击者B构造的恶意网页时，浏览器会自动带上用户A在该网站上的有效Cookie和其他认证信息发起请求。
1.  由于服务器收到的请求带有合法用户的认证信息，于是误以为是用户A自主发起的请求，进而执行了请求中的操作。

防御CSRF的方法包括但不限于：

-   **Token验证**：服务器在发出表单提交页面时生成一个随机的、一次性的token，提交时需验证这个token，以证明请求是来源于服务器认可的页面而非伪造。
-   **双重Cookie验证**：除了Session Cookie，服务器还可以设置一个专门用于CSRF防护的Cookie，不包含敏感信息且设置HttpOnly标志防止JS读取，服务器在处理敏感操作时检查两者是否匹配。
-   **POST请求验证**：仅允许敏感操作通过POST方法发起，并尽量避免GET方法执行敏感操作，因为GET请求容易被嵌入到链接或图片标签中。
-   **检查Referer头**：虽然不是非常可靠，但在某些场景下，服务器可以通过检查HTTP请求头中的Referer来判断请求是否来自正确的源站。

综合使用多种防御手段可以大大提高网站抵抗CSRF攻击的能力。
#### ClickJacking
ClickJacking（点击劫持）是一种网络攻击技术，它通过覆盖一个透明或者不可见的界面，诱骗用户在不知情的情况下点击实际位于该界面上层的元素，使得用户在原本无意的地方触发了点击事件。这种攻击方式通常用来盗取用户信息、控制用户账户、传播恶意软件或者进行其他未授权操作。

ClickJacking攻击的工作原理：

1.  攻击者创建一个网页，在该网页中嵌入一个iframe指向目标网站的某个功能页面（如“赞”按钮、删除按钮等）。
1.  攻击者在自己的网页上放置一些吸引用户注意力的内容，同时将iframe完全透明化或者与背景融合，使得用户无法察觉底层的目标页面元素。
1.  当用户在攻击者页面上进行操作时，实际上可能是在点击经过精心布局的iframe内的功能按钮，这样就完成了攻击者预设的动作，而用户对此毫无感知。

防范ClickJacking的主要措施有：

-   **X-Frame-Options Header**：服务器端可以设置`X-Frame-Options`响应头来限制页面是否允许在frame或iframe中展示，可以选择deny（不允许任何页面嵌入）、sameorigin（只允许同源页面嵌入）或allow-from指定来源。
-   **Content Security Policy (CSP)** ：通过配置Content-Security-Policy头部，可以限制资源加载，其中包括frame-src或child-src指令来限制哪些页面可以嵌入iframe内。
-   **iframe 检测及遮罩层**：在网页中加入JavaScript代码检测当前页面是否在iframe中加载，并在必要时添加一层遮罩层阻止用户交互。
-   **用户交互设计改进**：对于敏感操作增加确认步骤，例如二次确认对话框，以及对涉及安全的关键操作采用非iframe形式展现。

总之，ClickJacking是一种利用视觉欺骗和页面嵌套技术的攻击方式，网站开发者应当采取合适的安全策略来预防此类攻击的发生。


### 设计模式
TODO
### TS
TODO
### JS
https://juejin.cn/post/6968713283884974088
https://juejin.cn/post/6844903911686406158
https://juejin.cn/post/6983904373508145189
TODO
### 打包构建
TODO
### React
TODO
### Vue
TODO

### 数据结构与算法
[面试经典 150 题](https://leetcode.cn/studyplan/top-interview-150/)

[LeetCode 热题 100](https://leetcode.cn/studyplan/top-100-liked/)

[剑指Offer](https://leetcode.cn/problemset/?page=1&search=LCR)
